###############################################################################
#
# IAR C/C++ Compiler V6.20.1.931/W32 for MSP430           14/Mar/2015  23:44:43
# Copyright 1996-2014 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430, 8K KickStart Edition 6.20
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430
#    Source file   =  
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\target\cc2480\hal_board.c
#    Command line  =  
#        -f C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\..\Source\ZASA.cfg
#        (-DZACCEL_BUF_LEN=128 -DHOST_MT_BAUD=9600 -DHOST_MT_RX_OLD=1
#        "-DHOST_MT_RX_FULL=(ZACCEL_BUF_LEN-1)" -DZACCEL_NV_CHANLIST=0x00008000
#        -DZACCEL_NV_PANID=0x0EEE)
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\target\cc2480\hal_board.c -D
#        ROUTER -D APP_BLINK_LEDS -lC
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\Router\List\ --remarks
#        --diag_suppress Pe068 -o
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\Router\Obj\ --debug
#        -D__MSP430F2274__ --warnings_are_errors -e --double=32 --clib -I
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\ -I
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\..\Source\ -I
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\..\..\common\zaccel\
#        -I C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\..\..\common\mt\ -I
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\..\..\target\include\
#        -I
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\..\..\target\cc2480\
#        --reduce_stack_usage -Ohz --require_prototypes
#    List file     =  
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\Router\List\hal_board.lst
#    Object file   =  
#        C:\Users\Madmilla\Desktop\eZ430-RF2480\ZASA\IAR\Router\Obj\hal_board.r43
#
###############################################################################

C:\Users\Madmilla\Desktop\eZ430-RF2480\target\cc2480\hal_board.c
      1          /**************************************************************************************************
      2              Filename:       hal_board.c
      3              Revised:        $Date: 2008-03-28 15:13:08 -0700 (Fri, 28 Mar 2008) $
      4              Revision:       $Revision: 16675 $
      5          
      6              Description: Board specific implementations for the Z-Accel DB using the MSP430F2274.
      7          
      8              Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10              IMPORTANT: Your use of this Software is limited to those specific rights
     11              granted under the terms of a software license agreement between the user
     12              who downloaded the software, his/her employer (which must be your employer)
     13              and Texas Instruments Incorporated (the "License").  You may not use this
     14              Software unless you agree to abide by the terms of the License. The License
     15              limits your use, and you acknowledge, that the Software may not be modified,
     16              copied or distributed unless embedded on a Texas Instruments microcontroller
     17              or used solely and exclusively in conjunction with a Texas Instruments radio
     18              frequency transceiver, which is integrated into your product.  Other than for
     19              the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20              works of, modify, distribute, perform, display or sell this Software and/or
     21              its documentation for any purpose.
     22          
     23              YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24              PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25              INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26              NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27              TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28              NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29              LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30              INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31              OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32              OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33              (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35              Should you have any questions regarding your right to use this Software,
     36              contact Texas Instruments Incorporated at www.TI.com.
     37          **************************************************************************************************/
     38          
     39          /* ------------------------------------------------------------------------------------------------
     40           *                                          Includes
     41           * ------------------------------------------------------------------------------------------------
     42           */
     43          
     44          #include "hal_board.h"

   \                                 In  segment DATA16_AN, at 0x3
   \   unsigned char volatile IFG2
   \                     IFG2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1b0
   \   unsigned short volatile ADC10CTL0
   \                     ADC10CTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x1b2
   \   unsigned short volatile ADC10CTL1
   \                     ADC10CTL1:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x1b4
   \   unsigned short volatile ADC10MEM
   \                     ADC10MEM:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x56
   \   unsigned char volatile DCOCTL
   \                     DCOCTL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x57
   \   unsigned char volatile BCSCTL1
   \                     BCSCTL1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x53
   \   unsigned char volatile BCSCTL3
   \                     BCSCTL3:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x21
   \   unsigned char volatile P1OUT
   \                     P1OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x22
   \   unsigned char volatile P1DIR
   \                     P1DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x23
   \   unsigned char volatile P1IFG
   \                     P1IFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x24
   \   unsigned char volatile P1IES
   \                     P1IES:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x25
   \   unsigned char volatile P1IE
   \                     P1IE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x26
   \   unsigned char volatile P1SEL
   \                     P1SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x27
   \   unsigned char volatile P1REN
   \                     P1REN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x28
   \   unsigned char const volatile P2IN
   \                     P2IN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x29
   \   unsigned char volatile P2OUT
   \                     P2OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2a
   \   unsigned char volatile P2DIR
   \                     P2DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2b
   \   unsigned char volatile P2IFG
   \                     P2IFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2c
   \   unsigned char volatile P2IES
   \                     P2IES:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2d
   \   unsigned char volatile P2IE
   \                     P2IE:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2e
   \   unsigned char volatile P2SEL
   \                     P2SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2f
   \   unsigned char volatile P2REN
   \                     P2REN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x19
   \   unsigned char volatile P3OUT
   \                     P3OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1a
   \   unsigned char volatile P3DIR
   \                     P3DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1b
   \   unsigned char volatile P3SEL
   \                     P3SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1d
   \   unsigned char volatile P4OUT
   \                     P4OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1e
   \   unsigned char volatile P4DIR
   \                     P4DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x1f
   \   unsigned char volatile P4SEL
   \                     P4SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x160
   \   unsigned short volatile TACTL
   \                     TACTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x162
   \   unsigned short volatile TACCTL0
   \                     TACCTL0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x170
   \   unsigned short volatile TAR
   \                     TAR:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x172
   \   unsigned short volatile TACCR0
   \                     TACCR0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x180
   \   unsigned short volatile TBCTL
   \                     TBCTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x192
   \   unsigned short volatile TBCCR0
   \                     TBCCR0:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x68
   \   unsigned char volatile UCB0CTL0
   \                     UCB0CTL0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x69
   \   unsigned char volatile UCB0CTL1
   \                     UCB0CTL1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x6a
   \   unsigned char volatile UCB0BR0
   \                     UCB0BR0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x6b
   \   unsigned char volatile UCB0BR1
   \                     UCB0BR1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x6e
   \   unsigned char const volatile UCB0RXBUF
   \                     UCB0RXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x6f
   \   unsigned char volatile UCB0TXBUF
   \                     UCB0TXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x120
   \   unsigned short volatile WDTCTL
   \                     WDTCTL:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x10fc
   \   unsigned char const volatile CALDCO_8MHZ
   \                     CALDCO_8MHZ:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x10fd
   \   unsigned char const volatile CALBC1_8MHZ
   \                     CALBC1_8MHZ:
   \   000000                DS8 1
     45          
     46          /* ------------------------------------------------------------------------------------------------
     47           *                                           Constants
     48           * ------------------------------------------------------------------------------------------------
     49           */
     50          
     51          // Count for ~20msec - ADC needs 17msec for refV to settle.
     52          #define ADC_WAIT_MSECS         20
     53          
     54          // Debounce for ~10msec.
     55          #define DEBOUNCE_MSECS         10
     56          
     57          /* ------------------------------------------------------------------------------------------------
     58           *                                           Macros
     59           * ------------------------------------------------------------------------------------------------
     60           */
     61          
     62          #define _PRAGMA(x) _Pragma(#x)
     63          #define HAL_ISR_FUNC_DECLARATION(f,v) _PRAGMA(vector=v) __interrupt void f(void)
     64          #define HAL_ISR_FUNC_PROTOTYPE(f)     __interrupt void f(void)
     65          #define HAL_ISR_FUNCTION(f,v)         HAL_ISR_FUNC_PROTOTYPE(f); HAL_ISR_FUNC_DECLARATION(f,v)
     66          
     67          /* Whereas a customer application may require one or more slaves on the SPI bus (which could be
     68           * but are not necessarily other ZACCEL modules).
     69           * Whereas it may be necessary to interrupt any message exchange on the SPI bus with any of the
     70           * slaves in order to exchange a message with a different (obviously higher priority) slave, and
     71           * then return to finish the original message with the original slave.
     72           * Therefore it is necessary that setting and clearing any particular slave select line be
     73           * physically separate from setting and clearing any particular protocol handshake.
     74           *
     75           * Whereas the RPC Protocol handshake requires that MRDY be set low and maintained low throughout
     76           * the possibly several, logically contiguous, exchanges of RPC commands on the SPI bus.
     77           * Whereas the cc2480 has the MPC430 host wired to only one ZACCEL slave on the SPI bus.
     78           * Therefore it was deemed simpler and easier to understand on a logical analyzer trace of the SPI
     79           * and RPC signals for the setting and clearing of the MRDY control line to be tied to the setting
     80           * and clearing of the slave select line.
     81           *
     82           * It may better serve the user to remove the control of the slave select line from the control of
     83           * the MRDY line and place it here, where it belongs, in the 4-wire SPI protocol control.
     84           *
     85           * Also to note: the cc2480 SPI slave does not tri-state the MOSI line when its SS is not asserted,
     86           * thus requiring external de-coupling hardware in order to support two or more slaves on the bus.
     87           */
     88          #define SS_Clr()
     89          #define SS_Set()
     90          
     91          #define RST_Clr()       (P3OUT |= BV(7))
     92          #define RST_Set()       (P3OUT &= ~BV(7))
     93          
     94          /* ------------------------------------------------------------------------------------------------
     95           *                                           Global Variables
     96           * ------------------------------------------------------------------------------------------------
     97           */
     98          
     99          // Flags set by ISR's to indicate events without blocking or invoking background functions.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    100          volatile uint16 halEventFlags = HAL_EVT_NONE;
   \                     halEventFlags:
   \   000000                DS8 2
    101          
    102          // Last value read from the ADC by ISR.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    103          volatile uint16 halAdcVal = 0;
   \                     halAdcVal:
   \   000000                DS8 2
    104          
    105          /* ------------------------------------------------------------------------------------------------
    106           *                                           Local Variables
    107           * ------------------------------------------------------------------------------------------------
    108           */
    109          
    110          // Software timers w/ +/- 1 sec resolution and 65535 msec max.

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    111          static volatile uint16 tmrTicks[HAL_TIMER_CNT];
   \                     tmrTicks:
   \   000000                DS8 8

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    112          static uint16 tmrPeriod[HAL_TIMER_CNT];
   \                     tmrPeriod:
   \   000000                DS8 8

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
    113          uint16 TACCR0_INIT;
   \                     TACCR0_INIT:
   \   000000                DS8 2
    114          
    115          #ifdef HOST_MT
    116          static uint8 rx0Buf[ZACCEL_BUF_LEN];
    117          static volatile uint8 rx0Head;
    118          static volatile uint8 rx0Time;
    119          static uint8 rx0Tail;
    120          static uint8 tx0Buf[ZACCEL_BUF_LEN];
    121          static uint8 tx0Head;
    122          static volatile uint8 tx0Tail;
    123          #endif
    124          
    125          /* ------------------------------------------------------------------------------------------------
    126           *                                           Local Functions
    127           * ------------------------------------------------------------------------------------------------
    128           */
    129          
    130          static void ioInit(void);
    131          static void halMcuInit(void);
    132          static void halTimerInit(void);
    133          static void halSPIInit(void);
    134          void halSPIRead(uint8 sss, uint8 *pBuf, uint8 len);
    135          void halSPIWrite(uint8 sss, uint8 *pBuf, uint8 len);
    136          
    137          #define INTERRUPT_PORT1()    HAL_ISR_FUNCTION(isrPort1, PORT1_VECTOR)
    138          #define INTERRUPT_PORT2()    HAL_ISR_FUNCTION(isrPort2, PORT2_VECTOR)
    139          #define INTERRUPT_TIMERA()   HAL_ISR_FUNCTION(isrTimerA, TIMERA0_VECTOR)
    140          #define INTERRUPT_ADC10()    HAL_ISR_FUNCTION(isrADC, ADC10_VECTOR)
    141          
    142          #ifdef HOST_MT
    143          static void halUARTInit(void);
    144          void halUARTWrite(uint8 port, uint8 *pBuf, uint8 len);
    145          #define INTERRUPT_RX0()      HAL_ISR_FUNCTION(isrRx0, USCIAB0RX_VECTOR)
    146          #define INTERRUPT_TX0()      HAL_ISR_FUNCTION(isrTx0, USCIAB0TX_VECTOR)
    147          #endif
    148          
    149          /**************************************************************************************************
    150           * @fn          halBoardInit
    151           *
    152           * @brief       This is the HAL board main initialization function for ZASA.
    153           *
    154           * input parameters
    155           *
    156           * None.
    157           *
    158           * output parameters
    159           *
    160           * None.
    161           *
    162           * @return      None.
    163           **************************************************************************************************
    164           */

   \                                 In  segment CODE, align 2
    165          void halBoardInit(void)
   \                     halBoardInit:
    166          {
    167            ioInit();
   \   000000   B012....     CALL    #ioInit
    168            halMcuInit();
   \   000004   B012....     CALL    #halMcuInit
    169            halTimerInit();
   \   000008   B012....     CALL    #halTimerInit
    170            halSPIInit();
   \   00000C   D2436900     MOV.B   #0x1, &0x69
   \   000010   F240A9006800 MOV.B   #0xa9, &0x68
   \   000016   F2D080006900 BIS.B   #0x80, &0x69
   \   00001C   8293....     CMP.W   #0x0, &halEventFlags
   \   000020   0338         JL      ??halBoardInit_0
   \   000022   7E400300     MOV.B   #0x3, R14
   \   000026   013C         JMP     ??halBoardInit_1
   \                     ??halBoardInit_0:
   \   000028   5E43         MOV.B   #0x1, R14
   \                     ??halBoardInit_1:
   \   00002A   C24E6A00     MOV.B   R14, &0x6a
   \   00002E   C2436B00     MOV.B   #0x0, &0x6b
   \   000032   F2D00E001B00 BIS.B   #0xe, &0x1b
   \   000038   D2C36900     BIC.B   #0x1, &0x69
    171          #ifdef HOST_MT
    172            halUARTInit();
    173          #endif
    174            halEventFlags = HAL_EVT_NONE;   // Clear event flags
   \   00003C   8243....     MOV.W   #0x0, &halEventFlags
    175          }
   \   000040   3041         RET
   \   000042                REQUIRE UCB0CTL1
   \   000042                REQUIRE UCB0CTL0
   \   000042                REQUIRE UCB0BR0
   \   000042                REQUIRE UCB0BR1
   \   000042                REQUIRE P3SEL
    176          
    177          /**************************************************************************************************
    178           * @fn          halSlaveReset
    179           *
    180           * @brief       This function makes a clean reset of the slave Z-Accel device.
    181           *
    182           * input parameters
    183           *
    184           * None.
    185           *
    186           * output parameters
    187           *
    188           * None.
    189           *
    190           * @return      None.
    191           **************************************************************************************************
    192           */

   \                                 In  segment CODE, align 2
    193          void halSlaveReset(void)
   \                     halSlaveReset:
    194          {
    195            RST_Set();
   \   000000   F2C080001900 BIC.B   #0x80, &0x19
    196            halDelay(10, TRUE);
   \   000006   B012....     CALL    #?Subroutine3
    197            RST_Clr();
   \                     ??CrossCallReturnLabel_0:
   \   00000A   F2D080001900 BIS.B   #0x80, &0x19
    198            halDelay(250, TRUE);
   \   000010   5D43         MOV.B   #0x1, R13
   \   000012   7C40FA00     MOV.B   #0xfa, R12
   \   000016   B012....     CALL    #halDelay
    199            while (!SRDY());  // Wait for the Z-Accel slave to signal that it is out of reset.
   \                     ??halSlaveReset_0:
   \   00001A   F2B040002800 BIT.B   #0x40, &0x28
   \   000020   FC2F         JC      ??halSlaveReset_0
    200          }
   \   000022   3041         RET
   \   000024                REQUIRE P3OUT
   \   000024                REQUIRE P2IN

   \                                 In  segment CODE, align 2
   \                     ?Subroutine3:
   \   000000   5D43         MOV.B   #0x1, R13
   \   000002   7C400A00     MOV.B   #0xa, R12
   \   000006   3040....     BR      #halDelay
    201          
    202          /**************************************************************************************************
    203           * @fn          ioInit
    204           *
    205           * @brief       This function initializes the DIO.
    206           *              MSP430x2xx: 6.2.7 Configuring Unused Port Pins
    207           *              Unused I/O pins should be configured as I/O function, output direction,
    208           *              and left unconnected on the PC board, to prevent a floating input and reduce power
    209           *              consumption. The value of the PxOUT bit is a don’t care.
    210           *
    211           * input parameters
    212           *
    213           * None.
    214           *
    215           * output parameters
    216           *
    217           * None.
    218           *
    219           * @return      None.
    220           **************************************************************************************************
    221           */

   \                                 In  segment CODE, align 2
    222          static void ioInit(void)
   \                     ioInit:
    223          {
    224            /* P1.0/1 are DO to control LED_1/2, active high.
    225             * P1.2 is a DI w/ int. pull-up high to receive switch press interrupt.
    226             */
    227            P1SEL = 0x00;
   \   000000   C2432600     MOV.B   #0x0, &0x26
    228            P1OUT = 0xFC;
   \   000004   F240FC002100 MOV.B   #0xfc, &0x21
    229            P1DIR = 0xFB;
   \   00000A   F240FB002200 MOV.B   #0xfb, &0x22
    230          
    231            /* Configure the push button for ISR on press down.
    232             */
    233            P1REN = SW1_BV;
   \   000010   E2422700     MOV.B   #0x4, &0x27
    234            P1IES = SW1_BV;
   \   000014   E2422400     MOV.B   #0x4, &0x24
    235            P1IFG = 0;
   \   000018   C2432300     MOV.B   #0x0, &0x23
    236            P1IE  = SW1_BV;
   \   00001C   E2422500     MOV.B   #0x4, &0x25
    237          
    238            /* P2.0 is the light sensor input to ADC10-0.
    239             * P2.1 is the light sensor input enable - set high to read ADC, then low to save power.
    240             */
    241            P2SEL = 0x01;
   \   000020   D2432E00     MOV.B   #0x1, &0x2e
    242            P2OUT = 0xDD;
   \   000024   F240DD002900 MOV.B   #0xdd, &0x29
    243            P2DIR = 0xBE;
   \   00002A   F240BE002A00 MOV.B   #0xbe, &0x2a
    244            /* P2.6 is a DI to receive SRDY (Slave Ready on RPC protocol.)
    245             * Configure the SRDY for ISR on active low so that slave does not timeout awaiting the RPC
    246             * handshake sequence and reset.
    247             */
    248            P2REN = BV(6);
   \   000030   F24040002F00 MOV.B   #0x40, &0x2f
    249            HAL_CFG_SRDY_ISR;
   \   000036   F24040002C00 MOV.B   #0x40, &0x2c
    250            P2IFG = 0;
   \   00003C   C2432B00     MOV.B   #0x0, &0x2b
    251            P2IE  = BV(6);
   \   000040   F24040002D00 MOV.B   #0x40, &0x2d
    252          
    253            /* P2.3 is a DI (M.W.)
    254             * P2.3 pull up resistor enabled
    255             */
    256            P2DIR &= ~BV(3);
   \   000046   F2C22A00     BIC.B   #0x8, &0x2a
    257            P2REN |= BV(3);
   \   00004A   F2D22F00     BIS.B   #0x8, &0x2f
    258            
    259            /* P3.0 is a DO to control SSn (Slave Select Not = active low.)
    260             * P3.6 is a DO to control MRDY (Master Ready on RPC protocol.)
    261             * P3.7 is a DO to control RSTn (Slave RESET Not = active low asserted.)
    262             */
    263            P3SEL = 0x00;
   \   00004E   C2431B00     MOV.B   #0x0, &0x1b
    264            P3OUT = 0x7F;
   \   000052   F2407F001900 MOV.B   #0x7f, &0x19
    265            P3DIR = 0xFF;
   \   000058   F2431A00     MOV.B   #0xff, &0x1a
    266          
    267            /* P4.0 is a DO to control Cfg0 (Slave Configuration Switch 0.)
    268             * - Set high configures slave to use 32-kHz crystal installed and used.
    269             * - Set low configures slave to use internal oscillator.
    270             * P4.1 is a DO to control Cfg1 (Slave Configuration Switch 1.)
    271             * - Set high configures slave to use SPI transport.
    272             * - Set low configures slave to use UART transport.
    273             *
    274             * P4.3.is a DO to control a door motor (M.W.)
    275             * - Set high to close the door
    276             * - Set low to open
    277             */
    278            P4SEL = 0x00;
   \   00005C   C2431F00     MOV.B   #0x0, &0x1f
    279            P4OUT = 0xFF;
   \   000060   F2431D00     MOV.B   #0xff, &0x1d
    280            P4DIR = 0xFF;
   \   000064   F2431E00     MOV.B   #0xff, &0x1e
    281          }
   \   000068   3041         RET
   \   00006A                REQUIRE P1SEL
   \   00006A                REQUIRE P1OUT
   \   00006A                REQUIRE P1DIR
   \   00006A                REQUIRE P1REN
   \   00006A                REQUIRE P1IES
   \   00006A                REQUIRE P1IFG
   \   00006A                REQUIRE P1IE
   \   00006A                REQUIRE P2SEL
   \   00006A                REQUIRE P2OUT
   \   00006A                REQUIRE P2DIR
   \   00006A                REQUIRE P2REN
   \   00006A                REQUIRE P2IES
   \   00006A                REQUIRE P2IFG
   \   00006A                REQUIRE P2IE
   \   00006A                REQUIRE P3SEL
   \   00006A                REQUIRE P3OUT
   \   00006A                REQUIRE P3DIR
   \   00006A                REQUIRE P4SEL
   \   00006A                REQUIRE P4OUT
   \   00006A                REQUIRE P4DIR
    282          
    283          /**************************************************************************************************
    284           * @fn          halMcuInit
    285           *
    286           * @brief       Turn off watchdog and set up system clock. Set system clock to 8 MHz if Vdd permits.
    287           *
    288           * input parameters
    289           *
    290           * None.
    291           *
    292           * output parameters
    293           *
    294           * None.
    295           *
    296           * @return      None.
    297           **************************************************************************************************
    298           */

   \                                 In  segment CODE, align 2
    299          static void halMcuInit(void)
   \                     halMcuInit:
    300          {
   \   000000   2183         SUB.W   #0x2, SP
    301            volatile uint16 tmp;
    302          
    303            WDTCTL = WDTPW | WDTHOLD;           // Disable the watchdog.
   \   000002   B240805A2001 MOV.W   #0x5a80, &0x120
    304          
    305            // Setup code taken from TI example code: msp430x22x4_adc11_temp.c.
    306            ADC10CTL1 = INCH_11 + ADC10DIV_3;   // Internal bus voltage, ADC10CLK/4
   \   000008   B012....     CALL    #?Subroutine4
    307            ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE;
    308          
    309            /* Allow Vdd to settle before reading it and re-configuring the system clock.
    310             * MSP FAE confirmed that it can take up to 1 second for the Vdd to settle.
    311             */
    312            __delay_cycles(250);
   \                     ??CrossCallReturnLabel_3:
   \   00000C                ////////////// Start of 250 cycles delay.
   \   00000C   003C         JMP     ??halMcuInit_3
   \                     ??halMcuInit_3:
   \   00000E   3F405100     MOV.W   #0x51, R15
   \                     ??halMcuInit_2:
   \   000012   3F53         ADD.W   #0xffff, R15
   \   000014   FE2F         JC      ??halMcuInit_2
   \   000016                ////////////// End of delay code.
    313          
    314            ADC10CTL0 |= ENC + ADC10SC;         // Sampling and conversion start.
   \   000016   B2D00300B001 BIS.W   #0x3, &0x1b0
    315            __low_power_mode_1();               // Low power during sampling period.
   \   00001C   32D05800     BIS.W   #0x58, SR
    316          
    317            // Measurement of AVcc/2 is in range 0 to 1023 indicating voltage from 0 to 1.5V.
    318            tmp = (halAdcVal * 30 + 512) >> 10; // Convert to units of 0.1V
   \   000020   1F42....     MOV.W   &halAdcVal, R15
   \   000024   0F5F         RLA.W   R15
   \   000026   0E4F         MOV.W   R15, R14
   \   000028   0F5F         RLA.W   R15
   \   00002A   0E5F         ADD.W   R15, R14
   \   00002C   0F5F         RLA.W   R15
   \   00002E   0E5F         ADD.W   R15, R14
   \   000030   0F5F         RLA.W   R15
   \   000032   0F5E         ADD.W   R14, R15
   \   000034   3F500002     ADD.W   #0x200, R15
   \   000038   8F10         SWPB    R15
   \   00003A   7FF3         AND.B   #0xff, R15
   \   00003C   0F11         RRA.W   R15
   \   00003E   0F11         RRA.W   R15
   \   000040   814F0000     MOV.W   R15, 0(SP)
    319          
    320            // Cannont use 8-MHz if the Calibration values have been erased or if the bus voltage < 2.2V.
    321            if ((tmp >= 22) && (CALBC1_8MHZ != 0xFF) && (CALDCO_8MHZ != 0xFF))
   \   000044   B19016000000 CMP.W   #0x16, 0(SP)
   \   00004A   0D28         JNC     ??halMcuInit_0
   \   00004C   F293FD10     CMP.B   #0xff, &0x10fd
   \   000050   0A24         JEQ     ??halMcuInit_0
   \   000052   F293FC10     CMP.B   #0xff, &0x10fc
   \   000056   0724         JEQ     ??halMcuInit_0
    322            {
    323              // Configure the system clock for 8-MHz by loading the calibrated values from the info memory.
    324              BCSCTL1 = CALBC1_8MHZ;
   \   000058   D242FD105700 MOV.B   &0x10fd, &0x57
    325              DCOCTL = CALDCO_8MHZ;
   \   00005E   D242FC105600 MOV.B   &0x10fc, &0x56
   \   000064   033C         JMP     ??halMcuInit_1
    326            }
    327            else
    328            {
    329              halEventFlags |= HAL_EVT_NO_8MHz;
   \                     ??halMcuInit_0:
   \   000066   B2D00080.... BIS.W   #0x8000, &halEventFlags
    330            }
    331          }
   \                     ??halMcuInit_1:
   \   00006C   2153         ADD.W   #0x2, SP
   \   00006E   3041         RET
   \   000070                REQUIRE WDTCTL
   \   000070                REQUIRE ADC10CTL1
   \   000070                REQUIRE ADC10CTL0
   \   000070                REQUIRE CALBC1_8MHZ
   \   000070                REQUIRE CALDCO_8MHZ
   \   000070                REQUIRE BCSCTL1
   \   000070                REQUIRE DCOCTL

   \                                 In  segment CODE, align 2
   \                     ?Subroutine4:
   \   000000   B24060B0B201 MOV.W   #0xb060, &0x1b2
   \   000006   B2403830B001 MOV.W   #0x3038, &0x1b0
   \   00000C   3041         RET
    332          
    333          /**************************************************************************************************
    334           * @fn          halTimerInit
    335           *
    336           * @brief       Turn off watchdog and set up system clock. Set system clock to 8 MHz.
    337           *
    338           * input parameters
    339           *
    340           * None.
    341           *
    342           * output parameters
    343           *
    344           * None.
    345           *
    346           * @return      None.
    347           **************************************************************************************************
    348           */

   \                                 In  segment CODE, align 2
    349          static void halTimerInit(void)
   \                     halTimerInit:
    350          {
    351            uint8 loop = 128;         // Count 8mHz by 65536 timer overflow.
   \   000000   7E408000     MOV.B   #0x80, R14
    352          
    353            if (halEventFlags & HAL_EVT_NO_8MHz)
   \   000004   8293....     CMP.W   #0x0, &halEventFlags
   \   000008   0234         JGE     ??halTimerInit_1
    354            {
    355              loop = 16;              // Count 1mHz by 65536 timer overflow.
   \   00000A   7E401000     MOV.B   #0x10, R14
    356            }
    357          
    358            BCSCTL1 |= DIVA_3;        // ACLK/8
   \                     ??halTimerInit_1:
   \   00000E   F2D030005700 BIS.B   #0x30, &0x57
    359            BCSCTL3 |= LFXT1S_2;      // ACLK = VLO
   \   000014   F2D020005300 BIS.B   #0x20, &0x53
    360          
    361            // Setup TimerB to calibrate TimerA.
    362            TBCCR0 = 65535;
   \   00001A   B2439201     MOV.W   #0xffff, &0x192
    363          
    364            // Setup TimerA to be calibrated.
    365            TACCR0 = 65535;
   \   00001E   B2437201     MOV.W   #0xffff, &0x172
    366            TACTL = TASSEL_1 + MC_1;  // ACLK, up count mode.
   \   000022   B24010016001 MOV.W   #0x110, &0x160
    367          
    368            // Calibrate TimerA.
    369            TBCTL = TBSSEL_2 + MC_1;  // SMCLK, up count mode.
   \   000028   B24010028001 MOV.W   #0x210, &0x180
    370          
    371            do {
    372              while ((TBCTL & TBIFG) == 0);
   \                     ??halTimerInit_0:
   \   00002E   92B38001     BIT.W   #0x1, &0x180
   \   000032   FD2B         JNC     ??halTimerInit_0
    373              TBCTL &= ~TBIFG;
   \   000034   92C38001     BIC.W   #0x1, &0x180
    374            } while (--loop);
   \   000038   7E53         ADD.B   #0xff, R14
   \   00003A   F923         JNE     ??halTimerInit_0
    375            TBCTL = TBCLR;            // Clear TimerB configuration.
   \   00003C   A2428001     MOV.W   #0x4, &0x180
    376          
    377            TACTL &= ~MC_1;           // Stop TimerA.
   \   000040   B2C010006001 BIC.W   #0x10, &0x160
    378            TACCR0_INIT = TAR;
   \   000046   1F427001     MOV.W   &0x170, R15
   \   00004A   824F....     MOV.W   R15, &TACCR0_INIT
    379            TACTL |= MC_1;            // Resume TimerA.
   \   00004E   B2D010006001 BIS.W   #0x10, &0x160
    380          
    381            // Configure TimerA for 1-msec ISR for driving the HAL S/W timers, timing key press+hold, etc.
    382            TACCR0 = TACCR0_INIT;     // 1 second by 12kHz / 8 -> 1.5kHz
   \   000054   824F7201     MOV.W   R15, &0x172
    383            TACCTL0 = CCIE;           // TACCR0 interrupt enabled
   \   000058   B24010006201 MOV.W   #0x10, &0x162
    384          }
   \   00005E   3041         RET
   \   000060                REQUIRE BCSCTL1
   \   000060                REQUIRE BCSCTL3
   \   000060                REQUIRE TBCCR0
   \   000060                REQUIRE TACCR0
   \   000060                REQUIRE TACTL
   \   000060                REQUIRE TBCTL
   \   000060                REQUIRE TAR
   \   000060                REQUIRE TACCTL0
    385          
    386          /**************************************************************************************************
    387           * @fn          halSPIInit
    388           *
    389           * @brief       This function initializes the SPI.
    390           *
    391           * input parameters
    392           *
    393           * None.
    394           *
    395           * output parameters
    396           *
    397           * None.
    398           *
    399           * @return      None.
    400           **************************************************************************************************
    401           */
    402          static void halSPIInit(void)
    403          {
    404            /* Set SWRST - UART logic held in reset state during configuration. */
    405            UCB0CTL1 = UCSWRST;
    406          
    407            /* Configure for Mastermode; 3-pin SPI mode; 8 bits per byte. */
    408            UCB0CTL0 = UCCKPH | UCMSB | UCMST | UCSYNC;
    409          
    410            // Configure baud for ~2.7 MB (8-MHz/3), or max without an 8-MHz system clock.
    411            UCB0CTL1 |= UCSSEL_2;
    412            if (halEventFlags & HAL_EVT_NO_8MHz)
    413            {
    414              UCB0BR0 = 0x01;
    415            }
    416            else
    417            {
    418              UCB0BR0 = 0x03;
    419            }
    420            UCB0BR1 = 0x00;
    421          
    422            P3SEL |= 0x0E;   // Select SPI functionality on DIO pins for MOSI, MISO, & CLK.
    423          
    424            /* Clear SWRST - release reset to operation */
    425            UCB0CTL1 &= ~UCSWRST;
    426          }
    427          
    428          /**************************************************************************************************
    429           * @fn          halSPIWrite
    430           *
    431           * @brief       This function blocks (polling) on the SPI port transaction. Note that the SPI
    432           *              master (this host application) must write in order to read, so this one write
    433           *              function has such a dual use in the code.
    434           *
    435           * input parameters
    436           *
    437           * @param       sss - SPI Slave to select
    438           * @param       pBuf - Pointer to the buffer that contains the data to transmit.
    439           * @param       len - Length of the data to transmit.
    440           *
    441           * output parameters
    442           *
    443           * @param       pBuf - Pointer to the buffer that gets filled with the Rx bytes.
    444           *
    445           * @return      None.
    446           **************************************************************************************************
    447           */

   \                                 In  segment CODE, align 2
    448          void halSPIWrite(uint8 sss, uint8 *pBuf, uint8 len)
   \                     halSPIWrite:
    449          {
    450            if (sss == HAL_SPI_ZACCEL)
   \   000000   4C93         CMP.B   #0x0, R12
   \   000002   0E20         JNE     ??halSPIWrite_2
   \   000004   093C         JMP     ??halSPIWrite_3
    451            {
    452              SS_Set();
    453          
    454              while (len--)
    455              {
    456                UCB0TXBUF = *pBuf;
   \                     ??halSPIWrite_1:
   \   000006   E24D6F00     MOV.B   @R13, &0x6f
    457                while (!(IFG2 & UCB0RXIFG));
   \                     ??halSPIWrite_0:
   \   00000A   E2B20300     BIT.B   #0x4, &0x3
   \   00000E   FD2B         JNC     ??halSPIWrite_0
    458                *pBuf++ = UCB0RXBUF;
   \   000010   DD426E000000 MOV.B   &0x6e, 0(R13)
   \   000016   1D53         ADD.W   #0x1, R13
    459              }
   \                     ??halSPIWrite_3:
   \   000018   4F4E         MOV.B   R14, R15
   \   00001A   7E53         ADD.B   #0xff, R14
   \   00001C   4F93         CMP.B   #0x0, R15
   \   00001E   F323         JNE     ??halSPIWrite_1
    460          
    461              SS_Clr();
    462            }
    463          }
   \                     ??halSPIWrite_2:
   \   000020   3041         RET
   \   000022                REQUIRE UCB0TXBUF
   \   000022                REQUIRE IFG2
   \   000022                REQUIRE UCB0RXBUF
    464          
    465          /**************************************************************************************************
    466           * @fn          halTimerSet
    467           *
    468           * @brief       This function sets the timer period and control flags as specified.
    469           *
    470           * input parameters
    471           *
    472           * @param       tIdx - HAL Timer index.
    473           * @param       period - Timer period in msecs (zero to turn off.)
    474           * @param       ctlFlags - Bit mask of timer control flags.
    475           *
    476           * output parameters
    477           *
    478           * None.
    479           *
    480           * @return      None.
    481           **************************************************************************************************
    482           */

   \                                 In  segment CODE, align 2
    483          void halTimerSet(uint8 tIdx, uint16 period, uint8 ctlFlags)
   \                     halTimerSet:
    484          {
   \   000000   0A12         PUSH.W  R10
   \   000002   4F4C         MOV.B   R12, R15
    485            halIntState_t s;
    486          
    487            if (ctlFlags & HAL_TIMER_AUTO)
   \   000004   4C4F         MOV.B   R15, R12
   \   000006   0C5C         RLA.W   R12
   \   000008   5EB3         BIT.B   #0x1, R14
   \   00000A   0328         JNC     ??halTimerSet_0
    488            {
    489              tmrPeriod[tIdx] = period;
   \   00000C   8C4D....     MOV.W   R13, tmrPeriod(R12)
   \   000010   023C         JMP     ??halTimerSet_1
    490            }
    491            else
    492            {
    493              tmrPeriod[tIdx] = 0;
   \                     ??halTimerSet_0:
   \   000012   8C43....     MOV.W   #0x0, tmrPeriod(R12)
    494            }
    495          
    496            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??halTimerSet_1:
   \   000016   0A42         MOV.W   SR, R10
   \   000018   32C2         dint
   \   00001A   0343         nop
    497            tmrTicks[tIdx] = period;
   \   00001C   8C4D....     MOV.W   R13, tmrTicks(R12)
    498            halEventFlags &= ~BV(tIdx);
   \   000020   1C43         MOV.W   #0x1, R12
   \   000022   4E4F         MOV.B   R15, R14
   \   000024   B012....     CALL    #?ShiftLeft16
   \   000028   82CC....     BIC.W   R12, &halEventFlags
    499            HAL_EXIT_CRITICAL_SECTION(s);
   \   00002C   024A         MOV.W   R10, SR
    500          }
   \   00002E   3A41         POP.W   R10
   \   000030   3041         RET
    501          
    502          /**************************************************************************************************
    503           * @fn          halDelay
    504           *
    505           * @brief       Delay for milliseconds.
    506           *              Do not invoke with zero.
    507           *              Do not invoke with greater than 500 msecs.
    508           *              Invoking with very high frequency and/or with long delays will start to
    509           *              significantly impact the real time performance of TimerA tasks because this will
    510           *              invisibly overrun the period when the TimerA count remaining, when this function
    511           *              is invoked, is less than the delay requested.
    512           *
    513           * input parameters
    514           *
    515           * @param       msecs - Milliseconds to delay in low power mode.
    516           * @param       sleep - Enforces blocking delay in low power mode if set.
    517           *
    518           * output parameters
    519           *
    520           * None.
    521           *
    522           * @return      None.
    523           **************************************************************************************************
    524           */

   \                                 In  segment CODE, align 2
    525          void halDelay(uint8 msecs, uint8 sleep)
   \                     halDelay:
    526          {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0812         PUSH.W  R8
   \   000006   4A4D         MOV.B   R13, R10
    527            // Scaling for msecs depends on result of TimerA calibration.
    528            // stop = msecs * TACCR0_INIT / 1000
    529            // Division by 10 to prevent overflow:
    530            //
    531            uint16 stop = msecs * (TACCR0_INIT / 10) / (1000 / 10);
   \   000008   3B40....     MOV.W   #TACCR0_INIT, R11
   \   00000C   4C4C         MOV.B   R12, R12
   \   00000E   084C         MOV.W   R12, R8
   \   000010   2C4B         MOV.W   @R11, R12
   \   000012   3E400A00     MOV.W   #0xa, R14
   \   000016   B012....     CALL    #?DivMod16u
   \   00001A   0E4C         MOV.W   R12, R14
   \   00001C   0C48         MOV.W   R8, R12
   \   00001E   B012....     CALL    #?Mul16
   \   000022   3E406400     MOV.W   #0x64, R14
   \   000026   B012....     CALL    #?DivMod16u
    532          
    533            HAL_DISABLE_INTERRUPTS();
   \   00002A   32C2         dint
   \   00002C   0343         nop
    534            TACTL &= ~MC_1;         // Stop the timer.
   \   00002E   B2C010006001 BIC.W   #0x10, &0x160
    535          
    536            if (TAR != TACCR0_INIT)
   \   000034   A29B7001     CMP.W   @R11, &0x170
   \   000038   0524         JEQ     ??halDelay_1
    537            {
    538              stop += TAR;
   \   00003A   1C527001     ADD.W   &0x170, R12
    539              if (stop == TACCR0_INIT)
   \   00003E   2C9B         CMP.W   @R11, R12
   \   000040   0120         JNE     ??halDelay_1
    540              {
    541                stop++;
   \   000042   1C53         ADD.W   #0x1, R12
    542              }
    543            }
    544            TACCR0 = stop;
   \                     ??halDelay_1:
   \   000044   824C7201     MOV.W   R12, &0x172
    545          
    546            TACTL |= MC_1;          // Re-start the timer.
   \   000048   B2D010006001 BIS.W   #0x10, &0x160
    547            HAL_ENABLE_INTERRUPTS();
   \   00004E   32D2         eint
    548          
    549            if (sleep)
   \   000050   4A93         CMP.B   #0x0, R10
   \   000052   0524         JEQ     ??halDelay_2
    550            {
    551              do {
    552                HAL_LOW_POWER_MODE();
   \                     ??halDelay_0:
   \   000054   32D0D800     BIS.W   #0xd8, SR
    553              } while (TACCR0 != TACCR0_INIT);
   \   000058   A29B7201     CMP.W   @R11, &0x172
   \   00005C   FB23         JNE     ??halDelay_0
    554            }
    555          }
   \                     ??halDelay_2:
   \   00005E   3040....     BR      #?Epilogue3
   \   000062                REQUIRE TACTL
   \   000062                REQUIRE TAR
   \   000062                REQUIRE TACCR0
    556          
    557          /**************************************************************************************************
    558           * @fn          halDelayDone
    559           *
    560           * @brief       Check to determine if a requested HAL delay is done.
    561           *
    562           * input parameters
    563           *
    564           * None.
    565           *
    566           * output parameters
    567           *
    568           * None.
    569           *
    570           * @return      None.
    571           **************************************************************************************************
    572           */

   \                                 In  segment CODE, align 2
    573          uint8 halDelayDone(void)
   \                     halDelayDone:
    574          {
    575            return (TACCR0 == TACCR0_INIT);
   \   000000   9292....7201 CMP.W   &TACCR0_INIT, &0x172
   \   000006   0224         JEQ     ??halDelayDone_0
   \   000008   4C43         MOV.B   #0x0, R12
   \   00000A   3041         RET
   \                     ??halDelayDone_0:
   \   00000C   5C43         MOV.B   #0x1, R12
   \   00000E   3041         RET
   \   000010                REQUIRE TACCR0
    576          }
    577          
    578          #ifndef COORDINATOR
    579          /**************************************************************************************************
    580           * @fn          halReadTemp
    581           *
    582           * @brief       This function starts the ADC and sets up to read the channel for temperature.
    583           *
    584           * input parameters
    585           *
    586           * None.
    587           *
    588           * output parameters
    589           *
    590           * None.
    591           *
    592           * @return      None.
    593           **************************************************************************************************
    594           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine2:
   \   000000   5D43         MOV.B   #0x1, R13
   \   000002   7C401400     MOV.B   #0x14, R12
   \   000006   B012....     CALL    #halDelay
   \   00000A   B2D00300B001 BIS.W   #0x3, &0x1b0
   \   000010   3041         RET

   \                                 In  segment CODE, align 2
    595          void halReadTemp(void)
   \                     halReadTemp:
    596          {
    597            // Setup code taken from eZ430-RF2500 Temperature Sensor End Device.
    598            ADC10CTL1 = INCH_10 + ADC10DIV_4;       // Temp Sensor ADC10CLK/5
   \   000000   B24080A0B201 MOV.W   #0xa080, &0x1b2
    599            ADC10CTL0 = SREF_1 + ADC10SHT_3 + REFON + ADC10ON + ADC10IE + ADC10SR;
   \   000006   B240383CB001 MOV.W   #0x3c38, &0x1b0
    600          
    601            halDelay(ADC_WAIT_MSECS, TRUE);         // Allow Vref to ADC to charge.
   \   00000C   ....         JMP     ?Subroutine2
   \   00000E                REQUIRE ADC10CTL1
   \   00000E                REQUIRE ADC10CTL0
    602            ADC10CTL0 |= ENC | ADC10SC;             // Sampling and conversion start
    603          }
    604          
    605          /**************************************************************************************************
    606           * @fn          halReadBusV
    607           *
    608           * @brief       This function sets up to read the channel for bus voltage.
    609           *
    610           * input parameters
    611           *
    612           * None.
    613           *
    614           * output parameters
    615           *
    616           * None.
    617           *
    618           * @return      None.
    619           **************************************************************************************************
    620           */

   \                                 In  segment CODE, align 2, keep-with-next
    621          void halReadBusV(void)
   \                     halReadBusV:
    622          {
    623            // Setup code taken from TI example code: msp430x22x4_adc10_temp.c.
    624            ADC10CTL1 = INCH_11 + ADC10DIV_3;       // Internal bus voltage, ADC10CLK/4
   \   000000   B012....     CALL    #?Subroutine4
    625            ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE;
    626          
    627            halDelay(ADC_WAIT_MSECS, TRUE);         // Allow Vref to ADC to charge.
   \                     ??CrossCallReturnLabel_2:
   \   000004                REQUIRE ?Subroutine2
   \   000004                REQUIRE ADC10CTL1
   \   000004                REQUIRE ADC10CTL0
   \   000004                // Fall through to label ?Subroutine2
    628            ADC10CTL0 |= ENC | ADC10SC;             // Sampling and conversion start
    629          }
    630          #endif
    631          
    632          /**************************************************************************************************
    633           * @fn          isrPort1
    634           *
    635           * @brief       This function services the Push Button interrupt.
    636           *
    637           * input parameters
    638           *
    639           * None.
    640           *
    641           * output parameters
    642           *
    643           * None.
    644           *
    645           * @return      None.
    646           **************************************************************************************************
    647           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   3E41         POP.W   R14
   \   000002   3F41         POP.W   R15
   \   000004   3C41         POP.W   R12
   \   000006   3D41         POP.W   R13
   \   000008   0013         RETI

   \                                 In  segment CODE, align 2
    648          INTERRUPT_PORT1()
   \                     isrPort1:
    649          {
   \   000000   0D12         PUSH.W  R13
   \   000002   0C12         PUSH.W  R12
   \   000004   0F12         PUSH.W  R15
   \   000006   0E12         PUSH.W  R14
    650            P1IE  = 0;
   \   000008   C2432500     MOV.B   #0x0, &0x25
    651            halDelay(DEBOUNCE_MSECS, TRUE);
   \   00000C   B012....     CALL    #?Subroutine3
    652            P1IFG = 0;
   \                     ??CrossCallReturnLabel_1:
   \   000010   C2432300     MOV.B   #0x0, &0x23
    653            P1IE  = SW1_BV;
   \   000014   E2422500     MOV.B   #0x4, &0x25
    654            halEventFlags |= HAL_EVT_BTN_PRESS;  // Signal that a key press+hold event has taken place.
   \   000018   B2D00001.... BIS.W   #0x100, &halEventFlags
    655          
    656            __low_power_mode_off_on_exit();
   \   00001E   B1C0F0000800 BIC.W   #0xf0, 0x8(SP)
    657          }
   \   000024   ....         JMP     ?Subroutine0
   \   000026                REQUIRE P1IE
   \   000026                REQUIRE P1IFG
    658          
    659          /**************************************************************************************************
    660           * @fn          isrPort2
    661           *
    662           * @brief       This function services the SRDY interrupt.
    663           *
    664           * input parameters
    665           *
    666           * None.
    667           *
    668           * output parameters
    669           *
    670           * None.
    671           *
    672           * @return      None.
    673           **************************************************************************************************
    674           */

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   B1C0F0000000 BIC.W   #0xf0, 0(SP)
   \   000006   0013         RETI

   \                                 In  segment CODE, align 2, keep-with-next
    675          INTERRUPT_PORT2()
   \                     isrPort2:
    676          {
    677            P2IFG = 0;
   \   000000   C2432B00     MOV.B   #0x0, &0x2b
    678            /* A sleeping host just needs to wake on SRDY. No flag needs to be set since Application-level
    679             * logic automatically polls for an asynchronous message from the slave.
    680             */
    681            __low_power_mode_off_on_exit();
   \   000004   ....         JMP     ?Subroutine1
   \   000006                REQUIRE P2IFG
    682          }
    683          
    684          /**************************************************************************************************
    685           * @fn          isrTimerA
    686           *
    687           * @brief       This function services the Timer-A interrupt.
    688           *
    689           * input parameters
    690           *
    691           * None.
    692           *
    693           * output parameters
    694           *
    695           * None.
    696           *
    697           * @return      None.
    698           **************************************************************************************************
    699           */

   \                                 In  segment CODE, align 2, keep-with-next
    700          INTERRUPT_TIMERA()
   \                     isrTimerA:
    701          {
   \   000000   0D12         PUSH.W  R13
   \   000002   0C12         PUSH.W  R12
   \   000004   0F12         PUSH.W  R15
   \   000006   0E12         PUSH.W  R14
   \   000008   9292....7201 CMP.W   &TACCR0_INIT, &0x172
   \   00000E   0F24         JEQ     ??isrTimerA_2
    702            uint8 idx;
    703          
    704            if (TACCR0 != TACCR0_INIT)
    705            {
    706              __low_power_mode_off_on_exit();
   \   000010   B1C0F0000800 BIC.W   #0xf0, 0x8(SP)
    707          
    708              if (TACCR0 < TACCR0_INIT)
   \   000016   1F42....     MOV.W   &TACCR0_INIT, R15
   \   00001A   829F7201     CMP.W   R15, &0x172
   \   00001E   032C         JC      ??isrTimerA_3
    709              {
    710                TACCR0 = TACCR0_INIT;
   \   000020   824F7201     MOV.W   R15, &0x172
    711                return;
   \   000024   223C         JMP     ??isrTimerA_1
    712              }
    713              TAR = 0;
   \                     ??isrTimerA_3:
   \   000026   82437001     MOV.W   #0x0, &0x170
    714              TACCR0 = TACCR0_INIT;
   \   00002A   824F7201     MOV.W   R15, &0x172
    715            }
    716          
    717          #ifdef HOST_MT
    718            if (rx0Time != 0)
    719            {
    720              // If an Rx byte is waiting.
    721              if (rx0Time >= HOST_MT_RX_OLD)
    722              {
    723                halEventFlags |= HAL_EVT_MT_RX_RDY;
    724                rx0Time = 0;
    725              }
    726              else
    727              {
    728                rx0Time++;
    729              }
    730            }
    731          #endif
    732          
    733            // Update all active S/W timers.
    734            for (idx = 0; idx < HAL_TIMER_CNT; idx++)
   \                     ??isrTimerA_2:
   \   00002E   4F43         MOV.B   #0x0, R15
    735            {
    736              if ((tmrTicks[idx] != 0) && (--tmrTicks[idx] == 0))
   \                     ??isrTimerA_0:
   \   000030   4E4F         MOV.B   R15, R14
   \   000032   0E5E         RLA.W   R14
   \   000034   8E93....     CMP.W   #0x0, tmrTicks(R14)
   \   000038   0F24         JEQ     ??isrTimerA_4
   \   00003A   1D4E....     MOV.W   tmrTicks(R14), R13
   \   00003E   3D53         ADD.W   #0xffff, R13
   \   000040   8E4D....     MOV.W   R13, tmrTicks(R14)
   \   000044   0920         JNE     ??isrTimerA_4
    737              {
    738                tmrTicks[idx] = tmrPeriod[idx];
   \   000046   9E4E........ MOV.W   tmrPeriod(R14), tmrTicks(R14)
    739                halEventFlags |= BV(idx);
   \   00004C   1C43         MOV.W   #0x1, R12
   \   00004E   4E4F         MOV.B   R15, R14
   \   000050   B012....     CALL    #?ShiftLeft16
   \   000054   82DC....     BIS.W   R12, &halEventFlags
    740              }
    741            }
   \                     ??isrTimerA_4:
   \   000058   5F53         ADD.B   #0x1, R15
   \   00005A   6F92         CMP.B   #0x4, R15
   \   00005C   E92B         JNC     ??isrTimerA_0
    742          
    743            if (halEventFlags != HAL_EVT_NONE)
   \   00005E   8293....     CMP.W   #0x0, &halEventFlags
   \   000062   0324         JEQ     ??isrTimerA_1
    744            {
    745              __low_power_mode_off_on_exit();
   \   000064   B1C0F0000800 BIC.W   #0xf0, 0x8(SP)
    746            }
    747          }
   \                     ??isrTimerA_1:
   \   00006A                REQUIRE ?Subroutine0
   \   00006A                REQUIRE TACCR0
   \   00006A                REQUIRE TAR
   \   00006A                // Fall through to label ?Subroutine0
    748          
    749          /**************************************************************************************************
    750           * @fn          isrADC
    751           *
    752           * @brief       This function services the ADC interrupt.
    753           *
    754           * input parameters
    755           *
    756           * None.
    757           *
    758           * output parameters
    759           *
    760           * None.
    761           *
    762           * @return      None.
    763           **************************************************************************************************
    764           */

   \                                 In  segment CODE, align 2, keep-with-next
    765          INTERRUPT_ADC10()
   \                     isrADC:
    766          {
    767            halAdcVal = ADC10MEM;             // Get sample from ADC
   \   000000   9242B401.... MOV.W   &0x1b4, &halAdcVal
    768            halEventFlags |= HAL_EVT_ADC;     // Signal that the ADC sample is ready.
   \   000006   B2D00002.... BIS.W   #0x200, &halEventFlags
    769          
    770            ADC10CTL0 &= ~ENC;                // Disable the ADC
   \   00000C   A2C3B001     BIC.W   #0x2, &0x1b0
    771            ADC10CTL0 &= ~(REFON + ADC10ON);  // Turn off A/D to save power
   \   000010   B2F0CFFFB001 AND.W   #0xffcf, &0x1b0
    772          
    773            __low_power_mode_off_on_exit();
   \   000016                REQUIRE ?Subroutine1
   \   000016                REQUIRE ADC10MEM
   \   000016                REQUIRE ADC10CTL0
   \   000016                // Fall through to label ?Subroutine1
    774          }

   \                                 In  segment INTVEC, offset 0x4, root
   \                     `??isrPort1::??INTVEC 4`:
   \   000004   ....         DC16    isrPort1

   \                                 In  segment INTVEC, offset 0x6, root
   \                     `??isrPort2::??INTVEC 6`:
   \   000006   ....         DC16    isrPort2

   \                                 In  segment INTVEC, offset 0xa, root
   \                     `??isrADC::??INTVEC 10`:
   \   00000A   ....         DC16    isrADC

   \                                 In  segment INTVEC, offset 0x12, root
   \                     `??isrTimerA::??INTVEC 18`:
   \   000012   ....         DC16    isrTimerA
    775          
    776          #ifdef HOST_MT
    777          /**************************************************************************************************
    778           * @fn          halUARTInit
    779           *
    780           * @brief       This function initializes the UART.
    781           *
    782           * input parameters
    783           *
    784           * None.
    785           *
    786           * output parameters
    787           *
    788           * None.
    789           *
    790           * @return      None.
    791           **************************************************************************************************
    792           */
    793          static void halUARTInit(void)
    794          {
    795            uint16 ubr;
    796          
    797            if (halEventFlags & HAL_EVT_NO_8MHz)
    798            {
    799              ubr = (1000000UL + HOST_MT_BAUD/2) / (uint32)HOST_MT_BAUD;
    800            }
    801            else
    802            {
    803              ubr = (8000000UL + HOST_MT_BAUD/2) / (uint32)HOST_MT_BAUD;
    804            }
    805          
    806            UCA0CTL1 = UCSWRST;     // Set SWRST - UART logic held in reset state.
    807          
    808            UCA0CTL0 = 0;           // Set Frame Format: no parity; one stop-bit; 8 bits per byte.
    809          
    810            /* Set source clock & baud rate. */
    811            UCA0CTL1 |= UCSSEL1;
    812            UCA0BR1 = ubr >> 8;
    813            UCA0BR0 = ubr;
    814          
    815            P3SEL |= 0x30;  /* P3.4, 5 - UART0 TXD, RXD */
    816          
    817            UCA0CTL1 &= ~UCSWRST;  // Clear SWRST - release reset to operation.
    818            IE2 |= UCA0RXIE;       // Enable Rx ISR.
    819          }
    820          
    821          /**************************************************************************************************
    822           * @fn          halUARTRead
    823           *
    824           * @brief       This function transfers the bytes read by ISR to the parameter buffer.
    825           *
    826           * input parameters
    827           *
    828           * @param       port - HAL_PORT_NUM to read.
    829           * @param       pBuf - Pointer to the buffer to copy up to len bytes of Rx.
    830           * @param       len - Max number of bytes to copy into pBuf.
    831           *
    832           * output parameters
    833           *
    834           * @param       pBuf - Pointer to the buffer that gets filled with the Rx bytes.
    835           *
    836           * @return      Number of bytes actually copied into pBuf.
    837           **************************************************************************************************
    838           */
    839          uint8 halUARTRead(uint8 port, uint8 *pBuf, uint8 len)
    840          {
    841            uint8 cnt = 0;
    842          
    843            if (port == HAL_PORT_MT)
    844            {
    845              while (len--)
    846              {
    847                if (rx0Tail == rx0Head)
    848                {
    849                  break;
    850                }
    851          
    852                *pBuf++ = rx0Buf[rx0Tail];
    853                if (rx0Tail == 0)
    854                {
    855                  rx0Tail = ZACCEL_BUF_LEN-1;
    856                }
    857                else
    858                {
    859                  rx0Tail--;
    860                }
    861                cnt++;
    862              }
    863            }
    864          
    865            return cnt;
    866          }
    867          
    868          /**************************************************************************************************
    869           * @fn          halUARTWrite
    870           *
    871           * @brief       This function sets up the UART Tx buffer to transmit by ISR.
    872           *
    873           * input parameters
    874           *
    875           * @param       port - HAL_PORT_NUM to write.
    876           * @param       pBuf - Pointer to the buffer that contains the data to transmit.
    877           * @param       len - Length of the data to transmit.
    878           *
    879           * output parameters
    880           *
    881           * None.
    882           *
    883           * @return      None.
    884           **************************************************************************************************
    885           */
    886          void halUARTWrite(uint8 port, uint8 *pBuf, uint8 len)
    887          {
    888            if (port == HAL_PORT_MT)
    889            {
    890              while (len--)
    891              {
    892                tx0Buf[tx0Head] = *pBuf++;
    893                if (tx0Head == 0)
    894                {
    895                  tx0Head = ZACCEL_BUF_LEN-1;
    896                }
    897                else
    898                {
    899                  tx0Head--;
    900                }
    901              }
    902              IE2 |= UCA0TXIE;  // Enable UART Tx ISR.
    903            }
    904          }
    905          
    906          /**************************************************************************************************
    907           * @fn          UART ISRs
    908           *
    909           * @brief       These ISRs handle Rx/Tx on UART0.
    910           *
    911           * input parameters
    912           *
    913           * None.
    914           *
    915           * output parameters
    916           *
    917           * None.
    918           *
    919           * @return      None.
    920           **************************************************************************************************
    921           */
    922          INTERRUPT_RX0()
    923          {
    924            uint8 tmp = rx0Head;
    925          
    926            rx0Buf[tmp] = UCA0RXBUF;
    927            if (tmp == 0)
    928            {
    929              tmp = ZACCEL_BUF_LEN-1;
    930            }
    931            else
    932            {
    933              tmp--;
    934            }
    935          
    936            rx0Head = tmp;
    937            tmp = rx0Tail - tmp;
    938          #if ZACCEL_BUF_LEN != 256
    939            if (tmp > ZACCEL_BUF_LEN)
    940            {
    941              tmp += ZACCEL_BUF_LEN;
    942            }
    943          #endif
    944            if (tmp >= HOST_MT_RX_FULL-1)
    945            {
    946              halEventFlags |= HAL_EVT_MT_RX_RDY;
    947            }
    948            else
    949            {
    950              rx0Time = 1;
    951            }
    952          }
    953          
    954          INTERRUPT_TX0()
    955          {
    956            if (tx0Tail != tx0Head)
    957            {
    958              UCA0TXBUF = tx0Buf[tx0Tail];
    959              if (tx0Tail == 0)
    960              {
    961                tx0Tail = ZACCEL_BUF_LEN-1;
    962              }
    963              else
    964              {
    965                tx0Tail--;
    966              }
    967            }
    968            else
    969            {
    970              IE2 &= ~UCA0TXIE;   // Disable interrupt.
    971            }
    972          }
    973          #endif

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      2   halBoardInit
        2   -> halMcuInit
        2   -> halTimerInit
        2   -> ioInit
      8   halDelay
      2   halDelayDone
      4   halMcuInit
      2   halReadBusV
        2   -> halDelay
      2   halReadTemp
        2   -> halDelay
      2   halSPIWrite
      2   halSlaveReset
        2   -> halDelay
      2   halTimerInit
      4   halTimerSet
      2   ioInit
      4   isrADC
     12   isrPort1
       12   -> halDelay
      4   isrPort2
     12   isrTimerA


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?Subroutine0
       8  ?Subroutine1
      18  ?Subroutine2
      10  ?Subroutine3
      14  ?Subroutine4
       2  ADC10CTL0
       2  ADC10CTL1
       2  ADC10MEM
       1  BCSCTL1
       1  BCSCTL3
       1  CALBC1_8MHZ
       1  CALDCO_8MHZ
       1  DCOCTL
       1  IFG2
       1  P1DIR
       1  P1IE
       1  P1IES
       1  P1IFG
       1  P1OUT
       1  P1REN
       1  P1SEL
       1  P2DIR
       1  P2IE
       1  P2IES
       1  P2IFG
       1  P2IN
       1  P2OUT
       1  P2REN
       1  P2SEL
       1  P3DIR
       1  P3OUT
       1  P3SEL
       1  P4DIR
       1  P4OUT
       1  P4SEL
       2  TACCR0
       2  TACCR0_INIT
       2  TACCTL0
       2  TACTL
       2  TAR
       2  TBCCR0
       2  TBCTL
       1  UCB0BR0
       1  UCB0BR1
       1  UCB0CTL0
       1  UCB0CTL1
       1  UCB0RXBUF
       1  UCB0TXBUF
       2  WDTCTL
       2  halAdcVal
      66  halBoardInit
      98  halDelay
      16  halDelayDone
       2  halEventFlags
     112  halMcuInit
       4  halReadBusV
      14  halReadTemp
      34  halSPIWrite
      36  halSlaveReset
      96  halTimerInit
      50  halTimerSet
     106  ioInit
      22  isrADC
       2  isrADC::??INTVEC 10
      38  isrPort1
       2  isrPort1::??INTVEC 4
       6  isrPort2
       2  isrPort2::??INTVEC 6
     106  isrTimerA
       2  isrTimerA::??INTVEC 18
       8  tmrPeriod
       8  tmrTicks

 
 864 bytes in segment CODE
  53 bytes in segment DATA16_AN
  22 bytes in segment DATA16_Z
   8 bytes in segment INTVEC
 
 864 bytes of CODE  memory
   0 bytes of CONST memory (+  8 bytes shared)
  22 bytes of DATA  memory (+ 53 bytes shared)

Errors: none
Warnings: none
